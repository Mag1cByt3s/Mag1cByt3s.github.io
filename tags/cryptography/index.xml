<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>cryptography - Tag - Pascal's Blog</title><link>https://blog.ppeinecke.de/tags/cryptography/</link><description>cryptography - Tag - Pascal's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 06 Apr 2022 14:07:33 +0200</lastBuildDate><atom:link href="https://blog.ppeinecke.de/tags/cryptography/" rel="self" type="application/rss+xml"/><item><title>picoCTF - Cryptography - Morse Code</title><link>https://blog.ppeinecke.de/posts/picoctf-cryptography-morse-code/</link><pubDate>Wed, 06 Apr 2022 14:07:33 +0200</pubDate><guid>https://blog.ppeinecke.de/posts/picoctf-cryptography-morse-code/</guid><description><![CDATA[<div class="featured-image">
                <img src="/featuredImages/picoCTF_logo.png" referrerpolicy="no-referrer">
            </div><h1 id="cryptography---morse-code---writeup">Cryptography - morse-code - writeup</h1>
<h2 id="description">description</h2>
<p>Morse code is well known. Can you decrypt this?
Download the file <!-- raw HTML omitted -->here<!-- raw HTML omitted -->.
Wrap your answer with picoCTF{},
put underscores in place of pauses, and use all lowercase.</p>
<h2 id="writeup">writeup</h2>
<p>Opening the file in ghex or sonic visualizer did not help</p>
<p>After reading the following article I decided to try to open it
using audacity.</p>
<p><!-- raw HTML omitted --><a href="https://dropn0w.medium.com/do-the-loop-downunderctf-2021-5d8ee86c0f2b" target="_blank" rel="noopener noreffer">https://dropn0w.medium.com/do-the-loop-downunderctf-2021-5d8ee86c0f2b</a><!-- raw HTML omitted --></p>
<p>Next I tried to interpret the waves as morse code.</p>
<p>I can see that there is a long pattern consisting
out of dashes and dots.
It looks like this:
</p>
<p>I ended up with the following morse code:</p>
<pre><code>.-- .... ....- --... .... ....- --... .... ----. ----- -.. .-- ..--- ----- ..- ----. .... --...
</code></pre>
<p>Using cyberchef &lsquo;From Morse Code&rsquo; I end up with the following string:</p>
<pre><code>WH47H47H90DW20U9H7
</code></pre>
<p>Since the task says &ldquo;Wrap your answer with picoCTF{}, put underscores in place of pauses, and use all lowercase.&rdquo;</p>
<p>I ended up with the following flag:</p>
<pre><code>picoCTF{wh47_h47h_90d_w20u9h7}
</code></pre>
]]></description></item><item><title>picoCTF - Cryptography - credstuff</title><link>https://blog.ppeinecke.de/posts/picoctf-cryptography-credstuff/</link><pubDate>Wed, 06 Apr 2022 14:02:03 +0200</pubDate><guid>https://blog.ppeinecke.de/posts/picoctf-cryptography-credstuff/</guid><description><![CDATA[<div class="featured-image">
                <img src="/featuredImages/picoCTF_logo.png" referrerpolicy="no-referrer">
            </div><h1 id="cryptography---credstuff---writeup">Cryptography - credstuff - writeup</h1>
<h2 id="description">description</h2>
<p>We found a leak of a blackmarket website&rsquo;s login credentials.
Can you find the password of the user cultiris and successfully decrypt it?
Download the leak here. The first user in usernames.txt corresponds to the first password in passwords.txt. The second user corresponds to the second password, and so on.</p>
<h2 id="writeup">writeup</h2>
<p>let&rsquo;s write a python program that finds the corresponding password
for the user &lsquo;cultiris&rsquo;</p>
<p>According to the task description the n-th user corresponds to the n-th
password.</p>
<p>So my task here is to find the position of the user &lsquo;cultiris&rsquo;
in the file &lsquo;usernames.txt&rsquo; and find the password with the same
position in the file &lsquo;passwords.txt&rsquo;</p>
<p>Here is the program I came up with:</p>
<pre><code class="language-python">#!/usr/bin/env python3

username=&quot;cultiris&quot;
username_file=&quot;leak/usernames.txt&quot;
password_file=&quot;leak/passwords.txt&quot;

# find position of cultiris in file leak/usernames.txt
def search_string_in_file(file_name, string_to_search):
    &quot;&quot;&quot;Search for the given string in file and return lines containing that string,
    along with line numbers&quot;&quot;&quot;
    line_number = 0
    list_of_results = []
    # Open the file in read only mode
    with open(file_name, 'r') as read_obj:
        # Read all lines in the file one by one
        for line in read_obj:
            # For each line, check if line contains the string
            line_number += 1
            if string_to_search in line:
                # If yes, then add the line number &amp; line as a tuple in the list
                list_of_results.append((line_number, line.rstrip()))
    # Return list of tuples containing line numbers and lines where string is found
    return list_of_results

print(search_string_in_file(username_file, username))

# running this code so far we found the username 'cultiris' on line 378

# lets extract line 378 of the file leak/passwords.txt

lines = []                             		 # Declare an empty list named lines.
with open ('leak/passwords.txt', 'rt') as psswd_file: # Open leak/passwords.txt for reading text data.
    for line in psswd_file:                	 # For each line, stored as line,
        lines.append(line)           		 # add its contents to lines.
                          		
# now just print out line 378 to find the correct password
# for the user cultiris
# the index is 377 because arrays start at 0
print(lines[377])
</code></pre>
<p>Using my python program I found the username &lsquo;cultiris&rsquo;
on line 378:</p>
<pre><code>[(378, 'cultiris')]
</code></pre>
<p>So all I have to do now is to extract line 378
of the file &lsquo;passwords.txt&rsquo;.</p>
<p>I got this:</p>
<pre><code>cvpbPGS{P7e1S_54I35_71Z3}
</code></pre>
<p>This seems to be encrypted</p>
<p>We need a hint on how to solve this&hellip;</p>
<p>Let&rsquo;s take a look at the passwords.txt file:</p>
<p>If I search the file for the term &lsquo;pico&rsquo;, I found this line:</p>
<pre><code>pICo7rYpiCoU51N6PicOr0t13
</code></pre>
<p>I think that could be a hint to use ROT13 to decrypt the flag!</p>
<p>So let&rsquo;s try to rotate each character by 13 position using ROT13:</p>
<pre><code>picoCTF{C7r1F_54V35_71M3}
</code></pre>
<p>That is our flag!</p>
<p>Awesome!</p>
]]></description></item><item><title>picoCTF - Cryptography - basic-mod1</title><link>https://blog.ppeinecke.de/posts/picoctf-cryptography-basic-mod1/</link><pubDate>Wed, 06 Apr 2022 13:58:41 +0200</pubDate><guid>https://blog.ppeinecke.de/posts/picoctf-cryptography-basic-mod1/</guid><description><![CDATA[<div class="featured-image">
                <img src="/featuredImages/picoCTF_logo.png" referrerpolicy="no-referrer">
            </div><h1 id="cryptography---basic-mod1---writeup">Cryptography - basic-mod1 - writeup</h1>
<h2 id="description">description</h2>
<p>We found this weird message being passed around on the servers,
we think we have a working decrpytion scheme.
Download the message here. Take each number mod 37 and
map it to the following character set: 0-25 is the alphabet (uppercase),
26-35 are the decimal digits, and 36 is an underscore.
Wrap your decrypted message in the picoCTF flag
format (i.e. picoCTF{decrypted_message})</p>
<h2 id="writeup">writeup</h2>
<p>Lets write a simple python program which reads the message
into a string first.</p>
<p>Then I will read each number into an array and take each
number in the array mod 37</p>
<p>After that I will try to map each array field to the following scheme:</p>
<blockquote>
<p>0-25 is the alphabet (uppercase),
26-35 are the decimal digits, and 36 is an underscore.</p>
</blockquote>
<p>At the end I will warp the decoded message in the picoCTF
flag format like so: (i.e. picoCTF{decrypted_message})</p>
<pre><code class="language-python">#!/usr/bin/env python3

import string

# read the file into a string
with open('message.txt', 'r') as file:
    enc_msg = file.read()

# split the string by ' ' and insert the values into an array
enc_arr = enc_msg.split( )

# print out the array for test purposes
enc_arr_len = len(enc_arr)

# define empty mod_arr
mod_arr = []

# calculate modulo 37 of every number
for i in range(0, enc_arr_len):
        mod_arr.append(round(int(enc_arr[i]) % 37))

# get length of resulting array
mod_arr_len = len(mod_arr)

# define array for final string
final_string = []


for i in range(0, mod_arr_len):
        # try to map numbers from 0 to 25 to uppercase characters of the alphabet
        if 0 &lt;= int(mod_arr[i]) &lt;= 25:
                if(int(mod_arr[i]) == 0):
                        final_string.append('A')
                elif(int(mod_arr[i]) == 1):
                        final_string.append('B')
                elif(int(mod_arr[i]) == 2):
                        final_string.append('C')
                elif(int(mod_arr[i]) == 3):
                        final_string.append('D')
                elif(int(mod_arr[i]) == 4):
                        final_string.append('E')
                elif(int(mod_arr[i]) == 5):
                        final_string.append('F')
                elif(int(mod_arr[i]) == 6):
                        final_string.append('G')
                elif(int(mod_arr[i]) == 7):
                        final_string.append('H')
                elif(int(mod_arr[i]) == 8):
                        final_string.append('I')
                elif(int(mod_arr[i]) == 9):
                        final_string.append('J')
                elif(int(mod_arr[i]) == 10):
                        final_string.append('K')
                elif(int(mod_arr[i]) == 11):
                        final_string.append('L')
                elif(int(mod_arr[i]) == 12):
                        final_string.append('M')
                elif(int(mod_arr[i]) == 13):
                        final_string.append('N')
                elif(int(mod_arr[i]) == 14):
                        final_string.append('O')
                elif(int(mod_arr[i]) == 15):
                        final_string.append('P')
                elif(int(mod_arr[i]) == 16):
                        final_string.append('Q')
                elif(int(mod_arr[i]) == 17):
                        final_string.append('R')
                elif(int(mod_arr[i]) == 18):
                        final_string.append('S')
                elif(int(mod_arr[i]) == 19):
                        final_string.append('T')
                elif(int(mod_arr[i]) == 20):
                        final_string.append('U')
                elif(int(mod_arr[i]) == 21):
                        final_string.append('V')
                elif(int(mod_arr[i]) == 22):
                        final_string.append('W')
                elif(int(mod_arr[i]) == 23):
                        final_string.append('X')
                elif(int(mod_arr[i]) == 24):
                        final_string.append('Y')
                elif(int(mod_arr[i]) == 25):
                        final_string.append('Z')
        # try to map numbers from 26 to 35 to decimal digits
        elif 26 &lt;= int(mod_arr[i]) &lt;= 35:
                if(int(mod_arr[i]) == 26):
                        final_string.append('0')
                elif(int(mod_arr[i]) == 27):
                        final_string.append('1')
                elif(int(mod_arr[i]) == 28):
                        final_string.append('2')
                elif(int(mod_arr[i]) == 29):
                        final_string.append('3')
                elif(int(mod_arr[i]) == 30):
                        final_string.append('4')
                elif(int(mod_arr[i]) == 31):
                        final_string.append('5')
                elif(int(mod_arr[i]) == 32):
                        final_string.append('6')
                elif(int(mod_arr[i]) == 33):
                        final_string.append('7')
                elif(int(mod_arr[i]) == 34):
                        final_string.append('8')
                elif(int(mod_arr[i]) == 35):
                        final_string.append('9')
        # try to map 36 to an underscore _
        elif int(mod_arr[i]) == 36:
                final_string.append(&quot;_&quot;)

final_flag = ''.join(final_string)

print(&quot;picoCTF{&quot; + final_flag + &quot;}&quot;)
</code></pre>
<h2 id="flag">Flag:</h2>
<pre><code>picoCTF{R0UND_N_R0UND_B0D5F596}
</code></pre>
]]></description></item></channel></rss>